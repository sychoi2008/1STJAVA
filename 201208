/* 1부터 10 출력
   for(int i = 1; i<=10; i++)
      System.out.println(i);

   int j = 1;
   while(j<=10){
      System.out.println(j);
      j++;
   }
 */


/* 10~1 print
  for(int i = 10; i>=1; i--){
    System.out.println(i);
   }
*/


/* 짝수 출력
  for(int i=1; i<=10; i++){
      if(i%2==0) System.out.println(i);
  }

   int j = 1;
   while(j<=10){
      if(j%2==0) System.out.println(j);
      j++;
   }
*/


/* 홀수 출력
   for(int i=1; i<=10; i++){
       if(i%2!=0) System.out.println(i);
   }
   
   int j = 1;
   while(j<=10){
      if(j%2!=0) System.out.println(j);
      j++;
    }
*/


/* 1~10 더하기
   int sum = 0;
   for(int i=1; i<=10; i++) sum+=i;
   System.out.println(sum);
 */


 /* a~z 반복문 char에는 숫자가 들어갈 수 있기 때문에
    char a = 'a';
    for(; a<='z'; ) System.out.println(a++);

    for(char i = 'a'; i<='z'; i++){
        System.out.println(i);
    }
 */
 

/* 입력받은 값까지
   int fini = scanner.nextInt();
   for(int i = 1; i<=fini; i++) System.out.println(i);
*/


/* 두개의 정수를 입력받아서 작은 수부터 큰 수까지를 반복문을 사용하여 출력하기
   int num1 = scanner.nextInt();
   int num2 = scanner.nextInt();

   int big = (num1 > num2)? num1 : num2;
   int small = (num1 < num2)? num1 : num2;

   for(int i = small; i<=big; i++){
      System.out.println(i);
        }
*/

//별출력
/*
  int star = scanner.nextInt();
  for(int i =1; i<=star; i++) System.out.print("*");      
*/
       
       
/*
 int star = scanner.nextInt();
 for(int i = 1; i<=star ; i++){
     for(int j = 1; j<=star; j++){
         System.out.print("*");
  }
  System.out.println();
}
*/


/*
  int star = scanner.nextInt();
  for(int i = 1; i<=star ; i++){
      for(int j = 1; j<=i; j++){
          System.out.print("*");
       }
      System.out.println();
   }
*/


//오버라이딩, 오버로딩의 차이는?
// 배열 : (1) 자료형 타입(int, String) (2) 대괄호 (3) 배열명  => 자료형 타입을 복수개 갖고 있다.

   int [] numArray = new int[5]; // 배열 선언 : 메모리에 연속적으로 할당. 인트크기 다섯개를 할당해(new역할) 
   numArray[0] = 0;
   numArray[1] = 1;
   numArray[2] = 2;
   numArray[3] = 3;
   numArray[4] = 4;
        
// 만약 배열의 인덱스를 초과한다면? bulid는 되지만 run은 되지 않는다. EX) newArray[5] = 5;
// 만약 여기서 numArray을 다시 초기화한다면 ? 메모리 다시 재할당함. 이전 값은 실종

   for(int i = 0; i<5; i++){
      System.out.println(numArray[i]);
      }
      
// list : 검색 X 느려
// map  : 검색 O 빨라
// 배열은 검색이 느리다. 하지만 삽입은 좋음
        
/* int num = 10;
   int [] numArr = new int[num]; // c는 안되지만 자바는 된다.
*/



